<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Piano Roll Test</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #111827;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      overflow: hidden;
    }
    #root {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .piano-roll-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .piano-keys {
      width: 80px;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #374151;
      position: relative;
      z-index: 3;
    }
    .piano-key {
      height: 24px;
      min-height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-bottom: 1px solid #374151;
      cursor: pointer;
      user-select: none;
      position: relative;
      box-sizing: border-box;
    }
    .piano-key.white {
      background: #f3f4f6;
      color: #111827;
      z-index: 1;
    }
    .piano-key.black {
      background: #111827;
      color: white;
      height: 16px;
      margin: 0 -12px;
      z-index: 2;
      font-size: 0.8em;
    }
    .piano-key.active {
      background: #4CAF50;
      color: white;
    }
    .grid-container {
      flex: 1;
      overflow: auto;
      position: relative;
    }
    .grid {
      position: absolute;
      top: 0;
      left: 80px;
      right: 0;
      height: 100%;
      overflow: hidden;
    }
    
    .grid-rows {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    .grid-row {
      position: absolute;
      left: 0;
      right: 0;
      height: 24px;
      display: flex;
      pointer-events: none; /* Let clicks pass through to cells */
    }
    
    /* White key rows - full height */
    .grid-row.white-key {
      background: #1F2937;
      border-bottom: 1px solid #374151;
      z-index: 1;
    }
    
    /* Black key rows - half height */
    .grid-row.black-key {
      height: 16px;
      background: #111827;
      z-index: 2;
      margin-top: -8px;
    }
    
    /* Cells */
    .cell {
      width: 40px;
      height: 100%;
      border-right: 1px solid #374151;
      box-sizing: border-box;
      position: relative;
      cursor: pointer;
      pointer-events: auto; /* Ensure cells are clickable */
    }
    
    /* Active cells */
    .cell.active {
      background: #4CAF50;
      z-index: 3; /* Make sure active cells are above others */
    }
    
    /* Black key cells */
    .black-key .cell {
      background: #111827;
      height: 16px;
      z-index: 2; /* Keep black keys above white keys */
    }
    
    /* Ensure black keys don't block white keys */
    .white-key .cell {
      z-index: 1;
    }
    .controls {
      padding: 1rem;
      background: #1f2937;
      display: flex;
      gap: 1rem;
    }
    button {
      padding: 0.5rem 1rem;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #2563eb;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // Audio context for sound generation
    let audioContext;
    let oscillators = {};
    
    // Initialize audio context on user interaction
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    // Play a note
    function playNote(note, octave) {
      initAudio();
      
      // Stop any existing oscillator for this note
      stopNote(note + octave);
      
      // Calculate frequency
      const noteFreqs = {
        'C': 16.35, 'C#': 17.32, 'D': 18.35, 'D#': 19.45,
        'E': 20.60, 'F': 21.83, 'F#': 23.12, 'G': 24.50,
        'G#': 25.96, 'A': 27.50, 'A#': 29.14, 'B': 30.87
      };
      
      const frequency = noteFreqs[note] * Math.pow(2, octave);
      
      // Create oscillator
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.start();
      
      // Store oscillator to stop it later
      oscillators[note + octave] = { oscillator, gainNode };
      
      // Return the note ID for stopping later
      return note + octave;
    }
    
    // Stop a playing note
    function stopNote(noteId) {
      if (oscillators[noteId]) {
        const now = audioContext.currentTime;
        oscillators[noteId].gainNode.gain.setValueAtTime(
          oscillators[noteId].gainNode.gain.value, 
          now
        );
        oscillators[noteId].gainNode.gain.exponentialRampToValueAtTime(
          0.01, 
          now + 0.1
        );
        oscillators[noteId].oscillator.stop(now + 0.1);
        delete oscillators[noteId];
      }
    }
    
    // Stop all playing notes
    function stopAllNotes() {
      Object.keys(oscillators).forEach(noteId => {
        stopNote(noteId);
      });
    }
    
    // Piano Roll Component
    function VerticalPianoRoll() {
      const [notes, setNotes] = useState(Array(48).fill(0).map(() => Array(32).fill(false)));
      const [isPlaying, setIsPlaying] = useState(false);
      const [currentStep, setCurrentStep] = useState(0);
      const [bpm, setBpm] = useState(120);
      const playheadRef = useRef(null);
      const animationFrameRef = useRef(null);
      const lastStepTimeRef = useRef(0);
      
      // Note names for the piano keys (2 octaves)
      const noteNames = [
        'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B',
        'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B',
        'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B',
        'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'
      ];
      
      // Octave for each row (4 octaves total)
      const octaves = [
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
      ];
      
      // Toggle a note on/off
      const toggleNote = (row, col) => {
        const newNotes = [...notes];
        newNotes[row] = [...newNotes[row]];
        newNotes[row][col] = !newNotes[row][col];
        setNotes(newNotes);
        
        // Play the note when toggled on
        if (newNotes[row][col]) {
          const noteId = playNote(noteNames[row], octaves[row]);
          // Stop the note after 200ms
          setTimeout(() => stopNote(noteId), 200);
        }
      };
      
      // Play the sequence
      const playSequence = () => {
        // If already playing, stop
        if (isPlaying) {
          stopSequence();
          return;
        }
        
        // Initialize audio context on first play (required by browsers)
        initAudio();
        
        // Start playback
        setIsPlaying(true);
        setCurrentStep(0);
        lastStepTimeRef.current = performance.now();
        
        // Calculate step time in milliseconds (16th notes)
        const stepTime = (60 / bpm) * 1000 / 4;
        
        const playStep = (timestamp) => {
          // Stop if playback was stopped
          if (!isPlaying) return;
          
          const elapsed = timestamp - lastStepTimeRef.current;
          
          // If it's time to play the next step
          if (elapsed >= stepTime) {
            // Play all notes in the current step
            for (let row = 0; row < notes.length; row++) {
              if (notes[row][currentStep]) {
                // Play the note for 80% of the step time
                playNote(noteNames[row], octaves[row]);
                setTimeout(() => stopNote(noteNames[row] + octaves[row]), stepTime * 0.8);
              }
            }
            
            // Move to next step (loop back to 0 after last step)
            const nextStep = (currentStep + 1) % 32;
            setCurrentStep(nextStep);
            
            // Reset timing for next step
            lastStepTimeRef.current = timestamp - (elapsed % stepTime);
            
            // If we've looped back to the start, stop if we were on the last step
            if (nextStep === 0) {
              stopSequence();
              return;
            }
          }
          
          // Update playhead position
          if (playheadRef.current) {
            const playheadX = (currentStep * 40) + ((elapsed % stepTime) / stepTime * 40);
            playheadRef.current.style.transform = `translateX(${playheadX}px)`;
          }
          
          // Continue the animation loop
          animationFrameRef.current = requestAnimationFrame(playStep);
        };
        
        // Start the animation loop
        animationFrameRef.current = requestAnimationFrame(playStep);
      };
      
      // Stop the sequence
      const stopSequence = () => {
        setIsPlaying(false);
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
        stopAllNotes();
        setCurrentStep(0);
        if (playheadRef.current) {
          playheadRef.current.style.transform = 'translateX(0)';
        }
      };
      
      // Clean up on unmount
      useEffect(() => {
        return () => {
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
          stopAllNotes();
          if (audioContext && audioContext.state !== 'closed') {
            audioContext.close();
          }
        };
      }, []);
      
      // Create piano keys
      const pianoKeys = noteNames.map((note, index) => {
        const isBlack = note.includes('#');
        const octave = octaves[index];
        const noteId = note + octave;
        
        return (
          <div 
            key={index}
            className={`piano-key ${isBlack ? 'black' : 'white'}`}
            onMouseDown={() => playNote(note, octave)}
            onMouseUp={() => stopNote(noteId)}
            onMouseLeave={() => stopNote(noteId)}
          >
            {note}<sub>{octave}</sub>
          </div>
        );
      });
      
      // Create grid cells with proper key rows
      const gridRows = [];
      const notesPerOctave = 12;
      const totalNotes = 48; // 4 octaves
      const steps = 32; // Number of steps in the sequence
      
      // Create each row
      for (let i = 0; i < totalNotes; i++) {
        const noteIndex = i % notesPerOctave;
        const isBlackKey = [1, 3, 6, 8, 10].includes(noteIndex); // C#, D#, F#, G#, A#
        const top = i * 24; // Position each row
        
        gridRows.push(
          <div 
            key={i}
            className={`grid-row ${isBlackKey ? 'black-key' : 'white-key'}`}
            style={{
              top: `${top}px`,
              height: isBlackKey ? '16px' : '24px',
              zIndex: isBlackKey ? 2 : 1,
              pointerEvents: 'none' // Let clicks pass through to cells
            }}
          >
            {Array(steps).fill(0).map((_, colIndex) => (
              <div
                key={colIndex}
                className={`cell ${notes[i]?.[colIndex] ? 'active' : ''}`}
                onClick={(e) => {
                  e.stopPropagation(); // Prevent event bubbling
                  toggleNote(i, colIndex);
                }}
                style={{
                  pointerEvents: 'auto', // Ensure cells are clickable
                  position: 'relative',
                  zIndex: isBlackKey ? 2 : 1
                }}
              />
            ))}
          </div>
        );
      }
      
      return (
        <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
          <div className="controls">
            <button onClick={playSequence}>
              {isPlaying ? 'Stop' : 'Play'}
            </button>
            <div>
              <label>BPM: </label>
              <input 
                type="number" 
                value={bpm}
                onChange={(e) => setBpm(parseInt(e.target.value) || 120)}
                min="40"
                max="300"
                style={{ width: '60px', padding: '0.5rem' }}
              />
            </div>
          </div>
          <div className="piano-roll-container">
            <div className="piano-keys">
              {pianoKeys}
            </div>
            <div className="grid-container">
              <div className="grid">
                <div className="grid-rows">
                  {gridRows}
                </div>
                <div 
                  ref={playheadRef}
                  style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '2px',
                    height: '100%',
                    backgroundColor: 'red',
                    zIndex: 10,
                    pointerEvents: 'none',
                    transition: 'transform 0.1s linear',
                    boxShadow: '0 0 5px red'
                  }}
                />
              </div>
            </div>
          </div>
          <div style={{ padding: '1rem', background: '#1f2937', fontSize: '0.9em' }}>
            <p>Click on the grid to add/remove notes. Click the piano keys to play individual notes.</p>
            <p>Use the Play button to play the sequence. Adjust BPM to change the speed.</p>
          </div>
        </div>
      );
    }

    // Render the app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<VerticalPianoRoll />);
  </script>
</body>
</html>
